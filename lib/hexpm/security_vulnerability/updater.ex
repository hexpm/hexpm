defmodule Hexpm.SecurityVulnerability.Updater do
  @moduledoc false

  use GenServer

  require Logger

  alias Hexpm.Repository.Packages
  alias Hexpm.SecurityVulnerability.Disclosures

  @disclosure_download_url "https://osv-vulnerabilities.storage.googleapis.com/Hex/all.zip"

  @enforce_keys [:update_interval]
  defstruct [:update_interval, etag: nil]

  @start_opts [
    :timeout,
    :debug,
    :spawn_opt,
    name: __MODULE__,
    hibernate_after: to_timeout(second: 1)
  ]
  @start_keys [:start, :timeout, :debug, :spawn_opt, :hibernate_after]
  @init_opts [update_interval: to_timeout(minute: 30)]

  @spec start_link(opts :: Keyword.t()) :: GenServer.on_start()
  def start_link(opts) do
    {start_opts, init_opts} = Keyword.split(opts, @start_keys)

    with {:ok, start_opts} <- Keyword.validate(start_opts, @start_opts),
         {:ok, init_opts} <- Keyword.validate(init_opts, @init_opts) do
      GenServer.start_link(__MODULE__, init_opts, start_opts)
    end
  end

  @impl GenServer
  def init(opts) do
    update_interval = Keyword.fetch!(opts, :update_interval)
    {:ok, %__MODULE__{update_interval: update_interval}, {:continue, :update}}
  end

  @impl GenServer
  def handle_continue(:update, %__MODULE__{etag: etag, update_interval: update_interval} = state) do
    case Req.get!(url: @disclosure_download_url, headers: [{"If-None-Match", etag}]) do
      %Req.Response{status: 304, headers: %{"etag" => [etag]}} ->
        {:noreply, %__MODULE__{state | etag: etag}, update_interval}

      %Req.Response{status: 200, headers: %{"etag" => [etag]}, body: body} ->
        state = %__MODULE__{state | etag: etag}

        case upsert_disclosures(body) do
          :ok -> {:noreply, state, update_interval}
          {:error, reason} -> {:stop, {:error, reason}, state}
        end
    end
  end

  @impl GenServer
  def handle_info(:timeout, state), do: {:noreply, state, {:continue, :update}}

  @impl GenServer
  def handle_cast(:update, state), do: {:noreply, state, {:continue, :update}}

  @spec update(server :: GenServer.server()) :: :ok
  def update(server \\ __MODULE__), do: GenServer.cast(server, :update)

  defp upsert_disclosures(disclosures) do
    disclosures =
      disclosures
      |> Enum.map(fn {_filename, content} -> Jason.decode!(content) end)
      |> Enum.flat_map(&extract_disclosure_params/1)

    affected_package_names = disclosures |> Enum.map(& &1.package) |> Enum.uniq()

    package_ids = Packages.resolve_hexpm_package_ids(affected_package_names)

    disclosure_insert_params =
      Enum.flat_map(disclosures, fn %{package: package} = disclosure ->
        case Map.fetch(package_ids, package) do
          {:ok, package_id} ->
            [disclosure |> Map.drop([:package]) |> Map.put(:package_id, package_id)]

          :error ->
            Logger.warning("Package not found: #{package}")
            []
        end
      end)

    Disclosures.upsert(disclosure_insert_params)
  end

  defp extract_disclosure_params(disclosure) do
    %{
      "id" => id,
      "summary" => sumamry,
      "modified" => modified,
      "published" => published,
      "affected" => affected
    } = disclosure

    {:ok, modified_at, _offset} = DateTime.from_iso8601(modified)
    {:ok, published_at, _offset} = DateTime.from_iso8601(published)

    affected
    |> Enum.filter(&match?(%{"package" => %{"ecosystem" => "Hex"}, "ranges" => [_ | _]}, &1))
    |> Enum.group_by(& &1["package"]["name"], & &1["ranges"])
    |> Enum.map(fn {package, ranges} ->
      %{
        id: id,
        package: package,
        summary: sumamry,
        modified_at: DateTime.truncate(modified_at, :second),
        published_at: DateTime.truncate(published_at, :second),
        affected: ranges |> List.flatten() |> Enum.map(&extract_version_requirement_from_range/1),
        details: disclosure
      }
    end)
  end

  defp extract_version_requirement_from_range(%{"type" => "SEMVER", "events" => events}) do
    events
    |> Enum.reject(&match?(%{"introduced" => "0"}, &1))
    |> Enum.map_join(
      " and ",
      fn
        %{"introduced" => version} -> ">= #{pad_version(version)}"
        %{"fixed" => version} -> "< #{pad_version(version)}"
        %{"last_affected" => version} -> "<= #{pad_version(version)}"
      end
    )
    |> Version.parse_requirement!()
  end

  defp pad_version(version) do
    case String.split(version, ".", parts: 3) do
      [_, _, _] -> version
      [_, _] -> "#{version}.0"
      [_] -> "#{version}.0.0"
    end
  end
end
